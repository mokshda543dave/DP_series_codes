bool solve(int lastindex,int currindex,vector<int> stones,vector<vector<int>>& dp)
{
    if(currindex==stones.size()-1) return true;
    if(dp[lastindex][currindex]!=-1)  //already exists
   return dp[lastindex][currindex];
   int jumplen=stones[currindex]-stones[lastindex];
    for(int j=-1;j<=1;j++)
    {
        int newjumplen=jumplen+j;
        if(newjumplen>0)
        {
            auto it=find(stones.begin(),stones.end(),stones[currindex]+newjumplen);
            if(it!=stones.end()) //value exists
                if(solve(currindex,it-stones.begin(),stones,dp)) return dp[lastindex][currindex]=1;   //return true krne k bjae store krao dp array me; 
        }
    }
        return dp[lastindex][currindex]=0;  //return false krne k bjae store krao dp array me;
}

    bool canCross(vector<int>& stones) 
    {
        vector<vector<int> > dp(stones.size(),vector<int> (stones.size(),-1));
        return solve(0,0,stones,dp);
    }
